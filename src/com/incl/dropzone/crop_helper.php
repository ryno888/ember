<?php

namespace Kwerqy\Ember\com\incl\dropzone;

/**
 * @package mod\intf
 * @author Ryno Van Zyl
 */
class crop_helper extends \Kwerqy\Ember\com\intf\standard {

    //--------------------------------------------------------------------------------
 	// properties
 	//--------------------------------------------------------------------------------
	protected static $is_singleton = true;

    protected $cropped_data = [];
    protected $thumbnail_arr = [];
 	//--------------------------------------------------------------------------------
    /**
     * the super global file array for the uploaded file
     * @var type string
     */
 	public $SUPER_GLOBAL_FILE;
 	//--------------------------------------------------------------------------------
    /**
     * the source dir where the temp file is located in
     * @var type string
     */
 	public $src_dir;
    //--------------------------------------------------------------------------------
    /**
     * the destination dir where the temp file is located in
     * @var type string
     */
 	public $dest_dir;
    //--------------------------------------------------------------------------------
    /**
     * an array of data elements that is generated by the cropper
     * EG: ["x" => $cropper_x, "y" => $cropper_y, "width" => $cropper_width, "height" => $cropper_height, "rotate" => 0, "scaleX"=> 1, "scaleY" => 1]
     * @var type array
     */
    public $data;
    //--------------------------------------------------------------------------------
    /**
     * if this var is set to true, the original file will be moved to the dest_dir along with the cropped file.
     * @var type
     */
    public $keep_original = true;
    //--------------------------------------------------------------------------------
    private $cropped_filename;
    public  $base_name;
    public  $new_filename_prefix = "cropped_";
    private $src;
    private $dest;
    private $tmp_name;
    private $type;
    private $extension;
    private $msg;
    private $transparent = true;
    private $red = 0;
    private $green = 0;
    private $blue = 0;
    private $alpha = 0;
    public $background_color = false;

 	//--------------------------------------------------------------------------------
 	// functions
 	//--------------------------------------------------------------------------------
    function __construct() {

        //create the destination directory if it does not exist
        if(!empty($this->dest_dir)){
            $this->make_dir($this->dest_dir);
        }else{
            $this->msg = $this->code_to_message(10);
        }

        //check if the super global file data array is set
        if(empty($this->SUPER_GLOBAL_FILE)){ $this->msg = $this->code_to_message(11); }

        //check if the super global file data array is set
        if(empty($this->src_dir)){ $this->msg = $this->code_to_message(9); }

        //check if the super global file data array is set
        if(empty($this->data)){ $this->msg = $this->code_to_message(12); }

    }
 	//--------------------------------------------------------------------------------
    function init() {

        //set file data
        $this->set_file();

        //set source data
        $this->set_src();

        //set cropper data
        $this->set_data();

		switch ($this->background_color) {
			case "black":
				$this->red = 0;
				$this->green = 0;
				$this->blue = 0;
				$this->alpha = 0;
				break;
			default:
				$this->red = 255;
				$this->green = 255;
				$this->blue = 255;
				$this->alpha = 0;
				break;
		}
    }
    //--------------------------------------------------------------------------------
    /**
     * move the file from the default dir in the $_FILE to the specified tmp_dir
     */
    private function set_file() {
        $this->tmp_name = $this->SUPER_GLOBAL_FILE && isset($this->SUPER_GLOBAL_FILE["tmp_name"]) ? $this->SUPER_GLOBAL_FILE["tmp_name"] : false;
        $this->base_name = $this->SUPER_GLOBAL_FILE && isset($this->SUPER_GLOBAL_FILE["name"]) ? $this->SUPER_GLOBAL_FILE["name"] : false;

        if($this->tmp_name && $this->base_name){

            //move uploaded file to temp dir
            move_uploaded_file($this->tmp_name, $this->src_dir."/".$this->base_name);
            $this->src = $this->src_dir."/".$this->base_name;
            $this->dest = $this->dest_dir."/cropped_".$this->base_name;
            $this->make_dir($this->dest_dir);
        }
    }
    //--------------------------------------------------------------------------------

	/**
	 * move the file from the default dir in the $_FILE to the specified tmp_dir
	 * @param $filename
	 * @param false $new_filename
	 * @return string
	 */
    public function set_file_custom($filename, $new_filename = false) {
        $return = false;
        $this->src = $this->src_dir."/".$filename;
        $this->base_name = $filename;
		$file_parts = explode(".", basename($this->src));
		$ext = end($file_parts);

        if($new_filename) return $this->dest = "{$this->dest_dir}/{$new_filename}.{$ext}";
        return $this->dest = "{$this->dest_dir}/{$this->new_filename_prefix}{$filename}";
    }
    //--------------------------------------------------------------------------------
    /**
     * sets the image src data
     */
    private function set_src() {
        if (!empty($this->src)) {
            $type = exif_imagetype($this->src);

            if ($type) {
                $this->type = $type;
                $this->extension = image_type_to_extension($type);
            }
        }else{
            $this->msg = $this->code_to_message(9);
        }
    }
    //--------------------------------------------------------------------------------
	/**
	 * @param bool $bool
	 */
    public function set_transparent($bool = true) {
        $this->transparent = $bool;
    }

    //--------------------------------------------------------------------------------
	public function get_global_file() {
		return $this->SUPER_GLOBAL_FILE;
	}
    //--------------------------------------------------------------------------------
	public function set_global_file($filename) {
		$file_name_parts = explode(".", $filename);
		$this->SUPER_GLOBAL_FILE = $filename;
		$this->extension = ".".end($file_name_parts);
	}
    //--------------------------------------------------------------------------------

	/**
	 * sets the image src data
	 * @param $red
	 * @param $green
	 * @param $blue
	 * @param $alpha
	 */
    public function set_custom_color($red, $green, $blue, $alpha) {
        $this->red = $red;
        $this->green = $green;
        $this->blue = $blue;
        $this->alpha = $alpha;
    }
    //--------------------------------------------------------------------------------
    /**
     * encodes cropper data
     */
    private function set_data() {
        if (!empty($this->data)) {
            $this->data = json_decode(stripslashes($this->data));
        }
    }
    //--------------------------------------------------------------------------------
    private function make_dir($folder_url) {
        $folders_arr = explode("/", str_replace("\\", "/", $folder_url));
        $current_folder = false;
        foreach ($folders_arr as $folder) {
            if($current_folder[count($current_folder)-1] == $folder){
                $current_folder .= "$folder";
            }else{
                $current_folder .= "$folder/";
            }

            if (!is_dir($current_folder)) {
                mkdir($current_folder, 0777);
            }
        }
        return str_replace("//", "/", $current_folder);
    }
    //--------------------------------------------------------------------------------
    public function crop() {

        $this->init();
        if (!empty($this->src) && !empty($this->dest) && !empty($this->data)) {
            //init
            $src_img = false;
            switch ($this->type) {
                case IMAGETYPE_GIF:
                  $src_img = imagecreatefromgif($this->src);
                  break;

                case IMAGETYPE_JPEG:
                  $src_img = imagecreatefromjpeg($this->src);
                  break;

                case IMAGETYPE_PNG:
                  $src_img = imagecreatefrompng($this->src);
                  break;
            }

            if (!$src_img) {
                $this->msg = "Failed to read the image file";
                return;
            }

            $size = getimagesize($this->src);
            $size_w = $size[0]; // natural width
            $size_h = $size[1]; // natural height

            $src_img_w = $size_w;
            $src_img_h = $size_h;

            $degrees = 0;

            // Rotate the source image
            if (is_numeric($degrees) && $degrees != 0) {
                // PHP's degrees is opposite to CSS's degrees
                $new_img = imagerotate( $src_img, -$degrees, imagecolorallocatealpha($src_img, $this->red, $this->green, $this->blue, 127) );

                imagedestroy($src_img);
                $src_img = $new_img;

                $deg = abs($degrees) % 180;
                $arc = ($deg > 90 ? (180 - $deg) : $deg) * M_PI / 180;

                $src_img_w = $size_w * cos($arc) + $size_h * sin($arc);
                $src_img_h = $size_w * sin($arc) + $size_h * cos($arc);

                // Fix rotated image miss 1px issue when degrees < 0
                $src_img_w -= 1;
                $src_img_h -= 1;
            }

            $tmp_img_w = $this->data->width;
            $tmp_img_h = $this->data->height;
            $dst_img_w = $this->data->width;
            $dst_img_h = $this->data->height;

            $src_x = $this->data->x;
            $src_y = $this->data->y;

            if ($src_x <= -$tmp_img_w || $src_x > $src_img_w) {
                $src_x = $src_w = $dst_x = $dst_w = 0;
            } else if ($src_x <= 0) {
                $dst_x = -$src_x;
                $src_x = 0;
                $src_w = $dst_w = min($src_img_w, $tmp_img_w + $src_x);
            } else if ($src_x <= $src_img_w) {
                $dst_x = 0;
                $src_w = $dst_w = min($tmp_img_w, $src_img_w - $src_x);
            }

            if ($src_w <= 0 || $src_y <= -$tmp_img_h || $src_y > $src_img_h) {
                $src_y = $src_h = $dst_y = $dst_h = 0;
            } else if ($src_y <= 0) {
                $dst_y = -$src_y;
                $src_y = 0;
                $src_h = $dst_h = min($src_img_h, $tmp_img_h + $src_y);
            } else if ($src_y <= $src_img_h) {
                $dst_y = 0;
                $src_h = $dst_h = min($tmp_img_h, $src_img_h - $src_y);
            }

            // Scale to destination position and size
            $ratio = $tmp_img_w / $dst_img_w;
            $dst_x /= $ratio;
            $dst_y /= $ratio;
            $dst_w /= $ratio;
            $dst_h /= $ratio;

            $dst_img = imagecreatetruecolor($dst_img_w, $dst_img_h);

			if(!$this->transparent){
				// Add transparent background to destination image
				imagefill($dst_img, 0, 0, imagecolorallocatealpha($dst_img, $this->red, $this->green, $this->blue, $this->alpha));
            }else{
                imagefill($dst_img, 0, 0, imagecolorallocatealpha($dst_img, $this->red, $this->green, $this->blue, 127));
            }



            imagesavealpha($dst_img, true);
            $result = imagecopyresampled($dst_img, $src_img, $dst_x, $dst_y, $src_x, $src_y, $dst_w, $dst_h, $src_w, $src_h);

			if ($result) {
				switch ($this->type) {
					case IMAGETYPE_GIF:
						if (!imagegif($dst_img, $this->dest)) {
							$this->msg = "Failed to save the cropped image file";
						}
					  break;

					case IMAGETYPE_JPEG:
						if (!imagejpeg($dst_img, $this->dest)) {
							$this->msg = "Failed to save the cropped image file";
						}
					  $src_img = imagecreatefromjpeg($this->src);
					  break;

					case IMAGETYPE_PNG:
						if (!imagepng($dst_img, $this->dest)) {
							$this->msg = "Failed to save the cropped image file";
						}
					  break;
				}
			}

            imagedestroy($src_img);
            imagedestroy($dst_img);

            //delete original if not needed
            if($this->keep_original == true){
//                rename($this->src, $this->dest_dir."/".$this->base_name);
            }else{
                unlink($this->src);
            }

        }
    }
    //--------------------------------------------------------------------------------
    private function code_to_message($code) {
        $errors = array(
            1 =>'The uploaded file exceeds the upload_max_filesize directive in php.ini',
            2 =>'The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form',
            3 =>'The uploaded file was only partially uploaded',
            4 =>'No file was uploaded',
            6 =>'Missing a temporary folder',
            7 =>'Failed to write file to disk',
            8 =>'File upload stopped by extension',
            9 =>'The src is emtpy or has not been set',
            10 =>'The dest_dir is not set',
            11 =>'The super global $SUPER_GLOBAL_FILE array data has not been set.',
            12 =>'The cropper data has not been set',
        );

        if (array_key_exists($code, $errors)) {
            return $errors[$code];
        }

        return 'Unknown upload error';
    }
    //--------------------------------------------------------------------------------
    public function get_result() {
        return !empty($this->data) ? $this->dest : $this->src;
    }
    //--------------------------------------------------------------------------------
    public function get_msg() {
        return $this->msg;
    }
    //--------------------------------------------------------------------------------
    /**
     * @return array
     */
    public function get_cropped_data() {
        return $this->cropped_data;
    }
    //--------------------------------------------------------------------------------
    public function clear_temp() {

        $file = reset($this->cropped_data);

        if($file && file_exists($file)){
            \Kwerqy\Ember\com\os\os::removedir(dirname($file));
        }
    }
    //--------------------------------------------------------------------------------
    public function xcrop($filename, $options = []){

        $options = array_merge([
            "enable_transparency" => true,
            "dest" => false,
            "index" => false,
        ], $options);

        $fn_request = function($id, $datatype){
            return round(\Kwerqy\Ember\Ember::$request->get($id, $datatype));
        };

        $cropper_request_id = $fn_request("cropper_request_id", TYPE_STRING);
        $crop_x = $fn_request("crop_x", TYPE_FLOAT);
        $crop_y = $fn_request("crop_y", TYPE_FLOAT);
        $crop_width = $fn_request("crop_width", TYPE_FLOAT);
        $crop_height = $fn_request("crop_height", TYPE_FLOAT);
        $crop_x_scale = $fn_request("crop_scaleX", TYPE_FLOAT);
        $crop_y_scale = $fn_request("crop_scaleY", TYPE_FLOAT);
        $desired_width = $fn_request("desired_width", TYPE_FLOAT);
        $desired_height = $fn_request("desired_height", TYPE_FLOAT);
        $crop_rotate = $fn_request("crop_rotate", TYPE_FLOAT);
        $dest = dirname($filename)."/cropped";

        \Kwerqy\Ember\com\os\os::mkdir(dirname($filename)."/cropped");

        // folder path
        if($filename && file_exists($filename)){
            $data_arr = json_encode([
                "x" => $crop_x,
                "y" => $crop_y,
                "width" => $crop_width,
                "height" => $crop_height,
                "rotate" => $crop_rotate,
                "scaleX"=> $crop_x_scale,
                "scaleY" => $crop_y_scale,
            ]);

            //initialize cropper
            $cropper = crop_helper::make();
            $cropper->set_global_file($filename);
            $cropper->src_dir = dirname($filename);
            $cropper->data = $data_arr;
            $cropper->dest_dir = $dest;
            $cropper->keep_original = true;
            $cropper->set_transparent($options["enable_transparency"]);
            if(!$options["enable_transparency"])$cropper->set_custom_color(0, 0, 0, 0);
            $this->cropped_filename = $cropper->set_file_custom(basename($filename));
            $cropper->crop();

            $this->cropped_data["original"] = $filename;
			$this->cropped_data["cropped"] = $this->xthumbnail([
			    "filename" => $this->cropped_filename,
                "width" => $desired_width,
                "height" => $desired_height,
                "type" => "resizeToWidth",
            ]);

			foreach ($this->thumbnail_arr as $name => $thumbnail){
                $this->cropped_data["{$cropper_request_id}$name"] = $this->xthumbnail($thumbnail);
            }
        }

        return $this->cropped_data;
    }
    //--------------------------------------------------------------------------------
    /**
     * @param $width
     * @param $height
     * @param string $type = cut | maxarea | resizeToWidth | cropToHeight | cropToWidth | resize
     * @param array $options
     */
    public function make_thumbnail($width, $height, $type = "maxarea", $options = []) {

        $options_arr = array_merge([
            "x" => 0,
            "y" => 0,
        ], $options);

        $this->thumbnail_arr["thumb_{$type}_{$width}x{$height}"] = [
            "width" => $width,
            "height" => $height,
            "x" => $options_arr["x"],
            "y" => $options_arr["y"],
            "type" => $type,
        ];

    }
    //--------------------------------------------------------------------------------
    private function xthumbnail($options = []) {

        $options_arr = array_merge([
            "filename" => false,
            "width" => false,
            "height" => false,
            "x" => false,
            "y" => false,
            "type" => false,
        ], $options);

        $compressor = compressor::make($this->cropped_filename);

        switch ($options_arr["type"]){
            case "square": $compressor->square($options_arr["width"]); break;
            case "resizeToWidth": $compressor->resizeToWidth($options_arr["width"], $options_arr["height"]); break;
            case "cropToHeight": $compressor->cropToHeight($options_arr["width"], $options_arr["height"]); break;
            case "cropToWidth": $compressor->cropToWidth($options_arr["width"], $options_arr["height"]); break;
            case "resize": $compressor->resize($options_arr["width"], $options_arr["height"]); break;
            case "maxarea": $compressor->maxarea($options_arr["width"], $options_arr["height"]); break;
                break;
            case "cut": $compressor->cut($options_arr["x"], $options_arr["y"], $options_arr["width"], $options_arr["height"]); break;
        }

        if(!$options_arr["filename"]){
            $pathinfo = pathinfo($this->cropped_filename);
            $options_arr["filename"] = "{$pathinfo["dirname"]}/{$pathinfo["filename"]}_{$options_arr["width"]}x{$options_arr["height"]}.{$pathinfo["extension"]}";
        }

        $compressor->save($options_arr["filename"]);
        return $options_arr["filename"];
    }
    //--------------------------------------------------------------------------------
}